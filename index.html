<!DOCTYPE html><html lang="en"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taxonomy Hierarchy Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }

        .container {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            padding: 30px;
            margin: 0 auto;
            max-width: 1400px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 2.5em;
            color: #2c3e50;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .subtitle {
            font-size: 1.2em;
            color: #7f8c8d;
            margin-bottom: 20px;
        }

        .stats {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            display: inline-block;
            font-weight: bold;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.2);
        }

        .btn-primary {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(45deg, #27ae60, #229954);
            color: white;
        }

        .btn-tertiary {
            background: linear-gradient(45deg, #f39c12, #d68910);
            color: white;
        }

        .btn-quaternary {
            background: linear-gradient(45deg, #9b59b6, #8e44ad);
            color: white;
        }

        .search-container {
            margin-bottom: 20px;
            text-align: center;
        }

        .search-input {
            padding: 12px 20px;
            border: 2px solid #ddd;
            border-radius: 25px;
            width: 300px;
            font-size: 16px;
            outline: none;
            transition: border-color 0.3s ease;
        }

        .search-input:focus {
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.3);
        }

        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 15px;
            background: #f8f9fa;
            border-radius: 20px;
            border: 2px solid;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
        }

        #visualization {
            background: #fafafa;
            border-radius: 10px;
            border: 2px solid #e9ecef;
            overflow: hidden;
            box-shadow: inset 0 2px 10px rgba(0,0,0,0.05);
            min-height: 800px;
        }

        .node {
            cursor: pointer;
            filter: drop-shadow(2px 2px 4px rgba(0,0,0,0.1));
        }

        .node circle {
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .node:hover circle {
            stroke-width: 3px;
        }

        .node text {
            font-size: 12px;
            font-weight: 500;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.8);
        }

        .link {
            fill: none;
            stroke-width: 2px;
            transition: all 0.3s ease;
        }

        .tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .info-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            max-width: 300px;
            z-index: 1000;
            display: none;
        }

        .zoom-controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .zoom-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: #3498db;
            color: white;
            font-size: 20px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: all 0.3s ease;
        }

        .zoom-btn:hover {
            background: #2980b9;
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }
            
            .title {
                font-size: 2em;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
            }
            
            .search-input {
                width: 250px;
            }
            
            .info-panel {
                position: relative;
                top: auto;
                right: auto;
                margin-bottom: 20px;
                display: block;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1 class="title">üå≥ Taxonomy Hierarchy Explorer</h1>
            <p class="subtitle">Interactive visualization of reasoning taxonomy combinations</p>
            <div class="stats">
                Total Combinations: 1,800 (1 √ó 5 √ó 15 √ó 24)
            </div>
        </div>

        <div class="search-container">
            <input type="text" class="search-input" id="searchInput" placeholder="Search taxonomy items...">
        </div>

        <div class="legend">
            <div class="legend-item" style="border-color: #e74c3c;">
                <div class="legend-color" style="background: #e74c3c;"></div>
                <span>L1: Complex Reasoning</span>
            </div>
            <div class="legend-item" style="border-color: #27ae60;">
                <div class="legend-color" style="background: #27ae60;"></div>
                <span>L2: Reasoning Types</span>
            </div>
            <div class="legend-item" style="border-color: #f39c12;">
                <div class="legend-color" style="background: #f39c12;"></div>
                <span>L3: Specific Methods</span>
            </div>
            <div class="legend-item" style="border-color: #9b59b6;">
                <div class="legend-color" style="background: #9b59b6;"></div>
                <span>Use Cases</span>
            </div>
        </div>

        <div class="controls">
            <button class="btn btn-primary" onclick="expandAll()">üåü Expand All</button>
            <button class="btn btn-secondary" onclick="collapseAll()">üìÅ Collapse All</button>
            <button class="btn btn-tertiary" onclick="toggleLayout()">üîÑ Toggle Layout</button>
            <button class="btn btn-quaternary" onclick="exportData()">üíæ Export Data</button>
        </div>

        <div id="visualization"></div>
    </div>

    <div class="info-panel" id="infoPanel">
        <h3>üìä Node Information</h3>
        <div id="nodeInfo">Click on a node to see details</div>
    </div>

    <div class="zoom-controls">
        <button class="zoom-btn" onclick="zoomIn()">+</button>
        <button class="zoom-btn" onclick="zoomOut()">-</button>
        <button class="zoom-btn" onclick="resetZoom()">‚åÇ</button>
    </div>

    <script>
        // Data structure
        const taxonomyData = {
            "L1": ["Complex Reasoning"],
            "L2": ["Logical Reasoning", "Causal Reasoning", "Mathematical Reasoning", "Commonsense Reasoning", "Miscellaneous"],
            "L3": ["Propositional Logic", "Predicate Logic", "Decision Making", "Counterfactual Reasoning", "Arithmetic Reasoning", "Geometry Reasoning", "Scientific Reasoning", "Temporal Reasoning", "Spatial Reasoning", "Physical Reasoning", "Embodied Reasoning", "Long-Chain Reasoning", "Defeasible Reasoning", "Structured Formats Reasoning", "Optimization"],
            "UseCase": ["Chronological Sequencing", "Temporal Dependencies", "Multi-Step Problems", "Complex Scenarios", "Pattern Recognition", "Analyzing Arguments", "Identifying Assumptions", "Drawing Conclusions", "Data Interpretation", "Statistical Analysis", "Syllogisms", "Deductive Reasoning", "Inductive Reasoning", "Decision Trees", "Critical Path Method", "Resource Allocation", "Cause and Effect Analysis", "Decision Making", "Formatting Requirements", "JSON Manipulation", "Math Word Problems", "YAML Manipulation", "Planning", "Scheduling"]
        };

        // Color schemes
        const colors = {
            root: "#34495e",
            L1: "#e74c3c",
            L2: "#27ae60", 
            L3: "#f39c12",
            UseCase: "#9b59b6"
        };

        // Global variables
        let svg, g, root, tree, diagonal, zoom;
        let currentLayout = 'tree';
        let duration = 750;
        let i = 0;

        // Initialize visualization
        function initVisualization() {
            try {
                const container = d3.select("#visualization");
                container.selectAll("*").remove();
                
                const margin = {top: 40, right: 120, bottom: 40, left: 120};
                const width = 1200 - margin.left - margin.right;
                const height = 800 - margin.top - margin.bottom;

                // Create SVG
                svg = container
                    .append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom);

                // Create zoom behavior
                zoom = d3.zoom()
                    .scaleExtent([0.1, 3])
                    .on("zoom", function(event) {
                        if (g) {
                            g.attr("transform", event.transform);
                        }
                    });

                svg.call(zoom);

                // Create main group
                g = svg.append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                // Create tree layout
                tree = d3.tree().size([height, width - 200]);

                // Create diagonal path generator
                diagonal = d3.linkHorizontal()
                    .x(d => d.y || 0)
                    .y(d => d.x || 0);

                // Build hierarchy
                root = buildHierarchy();
                if (!root) {
                    console.error("Failed to build hierarchy");
                    return;
                }

                root.x0 = height / 2;
                root.y0 = 0;

                // Collapse all children initially for clean view
                if (root.children) {
                    root.children.forEach(collapse);
                }
                
                update(root);
                console.log("Visualization initialized successfully");
            } catch (error) {
                console.error("Error initializing visualization:", error);
            }
        }

        function buildHierarchy() {
            try {
                const rootNode = {
                    name: "Taxonomy Root",
                    level: "root",
                    children: []
                };

                taxonomyData.L1.forEach(l1Item => {
                    const l1Node = {
                        name: l1Item,
                        level: "L1",
                        children: []
                    };

                    taxonomyData.L2.forEach(l2Item => {
                        const l2Node = {
                            name: l2Item,
                            level: "L2",
                            children: []
                        };

                        taxonomyData.L3.forEach(l3Item => {
                            const l3Node = {
                                name: l3Item,
                                level: "L3",
                                children: []
                            };

                            taxonomyData.UseCase.forEach(useCase => {
                                l3Node.children.push({
                                    name: useCase,
                                    level: "UseCase"
                                });
                            });

                            l2Node.children.push(l3Node);
                        });

                        l1Node.children.push(l2Node);
                    });

                    rootNode.children.push(l1Node);
                });

                return d3.hierarchy(rootNode);
            } catch (error) {
                console.error("Error building hierarchy:", error);
                return null;
            }
        }

        function update(source) {
            if (!source || !tree || !g) {
                console.error("Missing required objects for update");
                return;
            }

            try {
                // Compute the new tree layout
                const treeData = tree(root);
                const nodes = treeData.descendants();
                const links = treeData.descendants().slice(1);

                // Normalize for fixed-depth
                nodes.forEach(d => {
                    d.y = d.depth * 180;
                    // Ensure x and y are numbers
                    if (isNaN(d.x)) d.x = 0;
                    if (isNaN(d.y)) d.y = 0;
                });

                // Update nodes
                const node = g.selectAll(".node")
                    .data(nodes, d => d.id || (d.id = ++i));

                // Enter new nodes
                const nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${source.y0 || 0},${source.x0 || 0})`)
                    .on("click", function(event, d) {
                        event.stopPropagation();
                        click(event, d);
                    })
                    .on("mouseover", function(event, d) {
                        showTooltip(event, d);
                    })
                    .on("mouseout", function() {
                        hideTooltip();
                    });

                // Add circles for nodes
                nodeEnter.append("circle")
                    .attr("r", 1e-6)
                    .style("fill", d => {
                        if (d._children) return colors[d.data.level] || "#bdc3c7";
                        return "#fff";
                    })
                    .style("stroke", d => colors[d.data.level] || "#bdc3c7")
                    .style("cursor", "pointer");

                // Add text labels
                nodeEnter.append("text")
                    .attr("dy", ".35em")
                    .attr("x", d => d.children || d._children ? -13 : 13)
                    .attr("text-anchor", d => d.children || d._children ? "end" : "start")
                    .text(d => truncateText(d.data.name, 20))
                    .style("fill-opacity", 1e-6)
                    .style("font-size", d => {
                        switch(d.data.level) {
                            case "root": return "16px";
                            case "L1": return "14px";
                            case "L2": return "12px";
                            case "L3": return "11px";
                            default: return "10px";
                        }
                    })
                    .style("font-weight", d => d.data.level === "root" ? "bold" : "normal");

                // Update existing nodes
                const nodeUpdate = nodeEnter.merge(node);

                // Transition to new position
                nodeUpdate.transition()
                    .duration(duration)
                    .attr("transform", d => `translate(${d.y || 0},${d.x || 0})`);

                // Update circle attributes
                nodeUpdate.select("circle")
                    .transition()
                    .duration(duration)
                    .attr("r", d => {
                        switch(d.data.level) {
                            case "root": return 8;
                            case "L1": return 7;
                            case "L2": return 6;
                            case "L3": return 5;
                            default: return 4;
                        }
                    })
                    .style("fill", d => {
                        if (d._children) return colors[d.data.level] || "#bdc3c7";
                        return "#fff";
                    })
                    .style("stroke", d => colors[d.data.level] || "#bdc3c7");

                // Update text
                nodeUpdate.select("text")
                    .transition()
                    .duration(duration)
                    .style("fill-opacity", 1);

                // Remove exiting nodes
                const nodeExit = node.exit().transition()
                    .duration(duration)
                    .attr("transform", d => `translate(${source.y || 0},${source.x || 0})`)
                    .remove();

                nodeExit.select("circle").attr("r", 1e-6);
                nodeExit.select("text").style("fill-opacity", 1e-6);

                // Update links
                const link = g.selectAll(".link")
                    .data(links, d => d.id);

                // Enter new links
                const linkEnter = link.enter().insert("path", "g")
                    .attr("class", "link")
                    .attr("d", d => {
                        const o = {x: source.x0 || 0, y: source.y0 || 0};
                        return diagonal({source: o, target: o});
                    })
                    .style("stroke", d => colors[d.data.level] || "#bdc3c7")
                    .style("stroke-opacity", 0.6);

                // Update existing links
                const linkUpdate = linkEnter.merge(link);

                linkUpdate.transition()
                    .duration(duration)
                    .attr("d", d => {
                        // Ensure source and target have valid coordinates
                        const source = {
                            x: d.parent ? (d.parent.x || 0) : 0,
                            y: d.parent ? (d.parent.y || 0) : 0
                        };
                        const target = {
                            x: d.x || 0,
                            y: d.y || 0
                        };
                        return diagonal({source: source, target: target});
                    })
                    .style("stroke-width", d => {
                        switch(d.data.level) {
                            case "L1": return 3;
                            case "L2": return 2.5;
                            case "L3": return 2;
                            default: return 1.5;
                        }
                    });

                // Remove exiting links
                link.exit().transition()
                    .duration(duration)
                    .attr("d", d => {
                        const o = {x: source.x || 0, y: source.y || 0};
                        return diagonal({source: o, target: o});
                    })
                    .remove();

                // Store old positions for transition
                nodes.forEach(d => {
                    d.x0 = d.x || 0;
                    d.y0 = d.y || 0;
                });
            } catch (error) {
                console.error("Error in update function:", error);
            }
        }

        function click(event, d) {
            try {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else if (d._children) {
                    d.children = d._children;
                    d._children = null;
                }
                update(d);
                showNodeInfo(d);
            } catch (error) {
                console.error("Error in click handler:", error);
            }
        }

        function collapse(d) {
            if (d.children) {
                d._children = d.children;
                d._children.forEach(collapse);
                d.children = null;
            }
        }

        function expand(d) {
            if (d._children) {
                d.children = d._children;
                d.children.forEach(expand);
                d._children = null;
            }
        }

        function truncateText(text, maxLength) {
            if (!text) return "";
            return text.length > maxLength ? text.substring(0, maxLength) + "..." : text;
        }

        // Tooltip functions
        function showTooltip(event, d) {
            try {
                hideTooltip();
                
                const tooltip = d3.select("body").append("div")
                    .attr("class", "tooltip")
                    .style("opacity", 0);

                let content = `<strong>${d.data.name}</strong><br/>`;
                content += `Level: ${d.data.level}<br/>`;
                content += `Depth: ${d.depth}<br/>`;
                
                if (d.children || d._children) {
                    const childCount = (d.children || d._children).length;
                    content += `Children: ${childCount}`;
                }

                tooltip.html(content)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px")
                    .transition()
                    .duration(200)
                    .style("opacity", 1);
            } catch (error) {
                console.error("Error showing tooltip:", error);
            }
        }

        function hideTooltip() {
            d3.selectAll(".tooltip").remove();
        }

        function showNodeInfo(d) {
            try {
                const infoPanel = document.getElementById("infoPanel");
                const nodeInfo = document.getElementById("nodeInfo");
                
                if (!infoPanel || !nodeInfo) return;
                
                let info = `<strong>Name:</strong> ${d.data.name}<br/>`;
                info += `<strong>Level:</strong> ${d.data.level}<br/>`;
                info += `<strong>Depth:</strong> ${d.depth}<br/>`;
                
                if (d.children || d._children) {
                    const children = d.children || d._children;
                    info += `<strong>Children:</strong> ${children.length}<br/>`;
                    
                    if (d.data.level === "L3") {
                        info += `<strong>Use Cases:</strong> ${children.length}`;
                    }
                }
                
                nodeInfo.innerHTML = info;
                infoPanel.style.display = "block";
            } catch (error) {
                console.error("Error showing node info:", error);
            }
        }

        // Control functions
        function expandAll() {
            try {
                if (root) {
                    root.descendants().forEach(expand);
                    update(root);
                }
            } catch (error) {
                console.error("Error expanding all:", error);
            }
        }

        function collapseAll() {
            try {
                if (root && root.children) {
                    root.children.forEach(collapse);
                    update(root);
                }
            } catch (error) {
                console.error("Error collapsing all:", error);
            }
        }

        function toggleLayout() {
            try {
                if (currentLayout === 'tree') {
                    tree = d3.tree()
                        .size([2 * Math.PI, 300])
                        .separation((a, b) => (a.parent == b.parent ? 1 : 2) / a.depth);
                    
                    diagonal = d3.linkRadial()
                        .angle(d => d.x || 0)
                        .radius(d => d.y || 0);
                    
                    currentLayout = 'radial';
                } else {
                    const height = 760;
                    const width = 960;
                    
                    tree = d3.tree().size([height, width]);
                    
                    diagonal = d3.linkHorizontal()
                        .x(d => d.y || 0)
                        .y(d => d.x || 0);
                    
                    currentLayout = 'tree';
                }
                
                if (root) {
                    update(root);
                }
            } catch (error) {
                console.error("Error toggling layout:", error);
            }
        }

        function zoomIn() {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1.5);
            }
        }

        function zoomOut() {
            if (svg && zoom) {
                svg.transition().call(zoom.scaleBy, 1 / 1.5);
            }
        }

        function resetZoom() {
            if (svg && zoom) {
                svg.transition().call(zoom.transform, d3.zoomIdentity);
            }
        }

        function exportData() {
            try {
                const data = {
                    taxonomy: taxonomyData,
                    combinations: 1800,
                    timestamp: new Date().toISOString()
                };
                
                const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'taxonomy-data.json';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            } catch (error) {
                console.error("Error exporting data:", error);
            }
        }

        // Search functionality
        function initSearch() {
            const searchInput = document.getElementById('searchInput');
            if (searchInput) {
                searchInput.addEventListener('input', function(e) {
                    try {
                        const searchTerm = e.target.value.toLowerCase();
                        
                        if (g) {
                            g.selectAll('.node text')
                                .style('fill', d => {
                                    return d.data.name.toLowerCase().includes(searchTerm) ? '#e74c3c' : '#333';
                                })
                                .style('font-weight', d => {
                                    return d.data.name.toLowerCase().includes(searchTerm) ? 'bold' : 'normal';
                                });
                        }
                    } catch (error) {
                        console.error("Error in search:", error);
                    }
                });
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            try {
                console.log("Initializing visualization...");
                initVisualization();
                initSearch();
            } catch (error) {
                console.error("Error during initialization:", error);
            }
        });

        // Handle window resize
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                try {
                    initVisualization();
                } catch (error) {
                    console.error("Error during resize:", error);
                }
            }, 250);
        });
    </script>


</body></html>
